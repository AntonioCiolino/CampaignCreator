import pytest
from campaign_crafter_api.app.core.security import encrypt_key, decrypt_key, _get_fernet_key
from campaign_crafter_api.app.core.config import settings
from cryptography.fernet import Fernet, InvalidToken

# Test the underlying key derivation to ensure it's consistent for tests
# This is more of a sanity check for the test setup itself.
def test_get_fernet_key_consistency():
    key1 = _get_fernet_key()
    key2 = _get_fernet_key()
    assert key1 == key2
    assert isinstance(key1, bytes)
    # Fernet keys must be 32 url-safe base64-encoded bytes.
    # Our _get_fernet_key hashes and then base64 encodes, so this should hold.
    Fernet(key1) # This will raise an error if key is invalid

def test_encrypt_decrypt_key_success():
    original_key = "test_api_key_12345"
    encrypted = encrypt_key(original_key)
    assert encrypted != original_key
    assert isinstance(encrypted, str)

    decrypted = decrypt_key(encrypted)
    assert decrypted == original_key

def test_decrypt_invalid_token():
    invalid_encrypted_key = "this_is_not_a_valid_fernet_token"
    decrypted = decrypt_key(invalid_encrypted_key)
    # As per implementation, should return empty string on InvalidToken
    assert decrypted == ""

def test_encrypt_decrypt_empty_string():
    original_key = ""
    encrypted = encrypt_key(original_key)
    # Implementation detail: encrypting an empty string might return a non-empty encrypted string
    # or handle it as a special case. Current implementation returns empty for empty input.
    assert encrypted == ""

    decrypted = decrypt_key(encrypted)
    assert decrypted == ""

def test_decrypt_random_bytes_as_string():
    # Test with something that's not a valid Fernet token at all
    # This is an example of a structurally valid Fernet token (starts with gAAAAA...)
    # We make it invalid by appending "corrupt"
    random_data_as_string = "gAAAAABl2h9qZm9vZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmY="
    decrypted = decrypt_key(random_data_as_string + "corrupt") # Make it invalid
    assert decrypted == ""

# It might also be useful to test decryption of a token encrypted with a DIFFERENT key
# to ensure it fails correctly, though this is implicitly covered by InvalidToken.
# def test_decrypt_token_from_different_key():
#     original_key = "another_test_key"
#
#     # Generate a different Fernet key for this test
#     # IMPORTANT: This assumes settings.SECRET_KEY can be temporarily altered or mocked,
#     # or that _get_fernet_key can be made to use a different input for testing.
#     # For simplicity, if _get_fernet_key is strictly tied to settings.SECRET_KEY,
#     # this test is harder to do in isolation without mocking.
#     # However, decrypting any random string not generated by the current Fernet instance
#     # effectively tests this. test_decrypt_invalid_token and test_decrypt_random_bytes_as_string cover this.
#
#     # Placeholder for a valid token generated by *another* fernet instance
#     # (e.g., manually create one for testing if direct generation here is complex)
#     # For example, if Fernet(key1).encrypt(b"data") gives token1
#     # And Fernet(key2).encrypt(b"data") gives token2
#     # Then decrypt_key(token2) using the system's main fernet instance (derived from settings.SECRET_KEY) should fail.
#     # This is generally covered by test_decrypt_invalid_token.
#     pass
